var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"J. A. Weideman and S. C. Reddy. 2000. A MATLAB differentiation matrix suite. ACM Trans. Math. Softw. 26, 4 (Dec. 2000), 465–519. https://doi.org/10.1145/365723.365727\nW. S. Don and A. Solomonoff. 1995. Accuracy and Speed in Computing the Chebyshev Collocation Derivative. SIAM J. Sci. Comput. 16, 6 (Nov. 1995), 1253–1268. https://doi.org/10.1137/0916073\nR. Baltensperger and M. R. Trummer. 2003. Spectral Differencing with a Twist. SIAM J. Sci. Comput. 24, 5 (Jan. 2003), 1465–1487. https://doi.org/10.1137/S1064827501388182\nP. Henrici. Essentials of Numerical Analysis. 1982. Wiley. (barycentric formula see page 252)\nP. Henrici. Applied & Computational Complex Analysis III. 1986. Wiley. (barycentric formula see page 46)","category":"page"},{"location":"api/#Library-API","page":"Library","title":"Library API","text":"","category":"section"},{"location":"api/","page":"Library","title":"Library","text":"The api is categorized by the underlying basis being used","category":"page"},{"location":"api/#Chebyshev","page":"Library","title":"Chebyshev","text":"","category":"section"},{"location":"api/","page":"Library","title":"Library","text":"chebdif\nchebdifft\nchebint\ncheb2bc\ncheb4c\ncheb1roots\ncheb1extrema","category":"page"},{"location":"api/#DMSuite.chebdif","page":"Library","title":"DMSuite.chebdif","text":"chebdif(N, M)\n\nComputes the differentiation matrices D1, D2, ..., DM on Chebyshev nodes. \n\nArguments\n\nN:        size of differentiation matrix.        \nM:        number of derivatives required [integer]. Note: 0 < M <= N-1.\n\nOutputs\n\nx:        the Chebyshev nodes.\nDM:       DM[1:N,1:N,ell] contains ell-th derivative matrix, ell=1,...,M.\n\nDetails\n\nThe code implements two strategies for enhanced  accuracy suggested by W. Don & S. Solomonoff in  SIAM J. Sci. Comp. Vol. 6, pp. 1253–1268 (1994). The two strategies are (a) the use of trigonometric  identities to avoid the computation of differences  x[k]-x[j] & (b) the use of the \"flipping trick\" which is necessary since sin(t) can be computed to high relative precision when t is small whereas sin(pi-t) cannot.\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.chebdifft","page":"Library","title":"DMSuite.chebdifft","text":"chebdifft(f,M)\n\nComputes the M'th approximate Chebyshev derivatives of the data vector f, using the FFT.\n\nArguments\n\nf: vector of length N containing function values at the Chebyshev points x[k] = cos((k-1)*pi/(N-1)), k = 1...N.\nM: derivative required [positive integer]\n\nOutputs\n\nDmf: vector containing approximate M'th derivative\n\nDetails\n\nA Fast Fourier Transform is used compute the Chebyshev cofficients of the data vector. A recursion formula is used to compute the Chebyshev coefficients for each derivative. A FFT is then used again to compute the derivatives in physical space.\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.chebint","page":"Library","title":"DMSuite.chebint","text":"chebint(fk, x)\n\nEvaluates the polynomial interpolant of the data points (xk[j], fk[j]), where  xk[j] are the Chebyshev nodes, at the points x.  Requires two or more data points.\n\nArguments\n\nfk: vector of y-coordinates of data; at Chebyshev points xk[j] = cos((j-1)*pi/(N-1)), j = 1...N.\nx: vector of x-values where polynomial interpolant is to be evaluated.\n\nOutputs\n\np: vector of interpolated values.\n\nDetails\n\nThe code implements the barycentric formula; see page 252 in P. Henrici; Essentials of Numerical Analysis; Wiley; 1982.\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.cheb2bc","page":"Library","title":"DMSuite.cheb2bc","text":"cheb2bc(N,g)\n\nComputes the first and second derivative matrices, as well as boundary condition functions,  for 2 point boundary conditions:\n\na1 u[1]  + b1 u'[1]  = c1\n\naN u[-1] + bN u'[-1] = cN\n\nArguments\n\nN:  number of Chebyshev points in [-1,1]\ng:  boundary condition matrix = [a1 b1 c1; aN bN cN]\n\nOutputs\n\nxt:  Chebyshev points corresponding to rows and columns of D1t & D2t\nD1t:  1st derivative matrix incorporating bc\nD2t:  2nd derivative matrix incorporating bc\nphip:  1st & 2nd derivative of bc function at x=1 (array with 2 columns)\nphim:  1st & 2nd derivative of bc function at x=-1 (array with 2 columns)\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.cheb4c","page":"Library","title":"DMSuite.cheb4c","text":"cheb4c(N)\n\nComputes the fourth derivative matrix on Chebyshev interior points, incorporating  the clamped boundary conditions:\n\nu[1]=u\"[1]=u[-1]=u\"[-1]=0.\n\nArguments\n\nN:     N-2 = order of differentiation matrix. (The interpolant has degree N+1.)\n\nOutputs\n\nx:      interior Chebyshev points [vector of length N-2]\nD4:     fourth derivative matrix  [size (N-2)x(N-2)]\n\nDetails\n\nThe code implements two strategies for enhanced  accuracy suggested by W. Don & S. Solomonoff in  SIAM J. Sci. Comp. Vol. 6, pp. 1253–1268 (1994). The two strategies are (a) the use of trigonometric  identities to avoid the computation of differences  x[k]-x[j] & (b) the use of the \"flipping trick\" which is necessary since sin(t) can be computed to high relative precision when t is small whereas sin(pi-t) cannot.\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.cheb1roots","page":"Library","title":"DMSuite.cheb1roots","text":"cheb1roots(N)\n\nComputes the roots of the Chebyshev polynomial of the first kind of degree N. AKA, Chebyshev-Gauss (CG) Points, or  Chebyshev points of the first kind.\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.cheb1extrema","page":"Library","title":"DMSuite.cheb1extrema","text":"cheb1extrema(N)\n\nComputes the extrama of the Chebyshev polynomial of the first kind of degree N. AKA, Chebyshev-Gauss-Lobatto (CGL) Points, or  Chebyshev points of the second kind.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hermite,-Laguerre,-and-Legendre","page":"Library","title":"Hermite, Laguerre, and Legendre","text":"","category":"section"},{"location":"api/","page":"Library","title":"Library","text":"herdif\nlagdif\nherroots\nlagroots\nlegroots","category":"page"},{"location":"api/#DMSuite.herdif","page":"Library","title":"DMSuite.herdif","text":"herdif(N, M, b)\n\nComputes the differentiation matrices D1, D2, ..., DM on Hermite points.\n\nArguments\n\nN: number of points, i.e., order of differentiation matrices [integer].\nM: number of derivatives required [integer]. Note that M must satisfy, 0 < M < N-1.\nb: scaling parameter [real, positive].\n\nOutputs\n\nx:    vector of nodes (zeros of Hermite polynomial of degree N scaled by the parameter b.)\nDM:   DM[1:N,1:N,ell] contains ell-th derivative matrix, ell=1,..,M.\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.lagdif","page":"Library","title":"DMSuite.lagdif","text":"lagdif(N, M, b)\n\nComputes the differentiation matrices D1, D2, ..., DM on Laguerre points.\n\nArguments\n\nN: number of points, i.e., order of differentiation matrices [integer].\nM: number of derivatives required [integer]. Note that M must satisfy, 0 < M < N-1.\nb: scaling parameter [real, positive].\n\nOutputs\n\nx: vector of nodes (zeros of Laguerre polynomial of degree N-1 plus x = 0), all scaled by the parameter b.\nDM: DM[1:N,1:N,ell] contains ell-th derivative matrix, ell=1,...,M.\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.herroots","page":"Library","title":"DMSuite.herroots","text":"herroots(N)\n\nComputes the roots of the Hermite polynomial of degree N.\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.lagroots","page":"Library","title":"DMSuite.lagroots","text":"lagroots(N)\n\nComputes the roots of the Laguerre polynomial of degree N.\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.legroots","page":"Library","title":"DMSuite.legroots","text":"legroots(N)\n\nComputes the roots of the Legendre polynomial of degree N.\n\n\n\n\n\n","category":"function"},{"location":"api/#Generic-Polynomial","page":"Library","title":"Generic Polynomial","text":"","category":"section"},{"location":"api/","page":"Library","title":"Library","text":"poldif\npolint","category":"page"},{"location":"api/#DMSuite.poldif","page":"Library","title":"DMSuite.poldif","text":"poldif(x, alpha, B)\n\nComputes the differentiation matrices D1, D2, ..., DM on arbitrary nodes, x, with associated weights, alpha.\n\nArguments\n\nx: vector of N distinct nodes.\nalpha: vector of weight values alpha(x), evaluated at x = x[k].\nB: matrix of size M x N;  where M is the highest derivative required.  It should contain the quantities \n\nB[ell,j] = beta(ell,j) = (ell-th derivative of alpha(x[j]))/alpha(x[j]). Note that M must satisfy, 0 < M < N-1.\n\nOutputs\n\nDM: DM[1:N,1:N,ell] contains ell-th derivative matrix, ell=1,...,M.\n\n\n\n\n\npoldif(x, M)\n\nComputes the differentiation matrices D1, D2, ..., DM on arbitrary nodes, x, with unit weights.\n\nArguments\n\nx: vector of N distinct nodes.\nM: the number of derivatives required [integer]. Note that M must satisfy, 0 < M < N-1.\n\nOutputs\n\nDM: DM[1:N,1:N,ell] contains ell-th derivative matrix, ell=1,...,M.\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.polint","page":"Library","title":"DMSuite.polint","text":"polint(xk, fk, x, alpxk, alpx)\n\nComputes the polynomial interpolant of the data [xk, fk] under the provided weights, alpxk and alpx.\n\nArguments\n\nxk:    vector of x-coordinates of data [assumed distinct].\nfk:    vector of y-coordinates of data.\nx:     vector of x-values where polynomial interpolant is to be evaluated.\nalpxk: vector of weight values sampled at the points xk.\nalpx:  vector of weight values sampled at the points x.\n\nOutputs\n\np:    vector of interpolated values.\n\nDetails\n\nThe code implements the barycentric formula; see page 252 in P. Henrici; Essentials of Numerical Analysis; Wiley; 1982.\n\nExcept for certain nice node distributions polynomial interpolation of high-degree is an ill-conditioned problem.  This code does not test for conditioning so use with care.\n\n\n\n\n\npolint(xk, fk, x)\n\nEvaluates the polynomial interpolant of the data [xk, fk], at the points x. Requires two or more data points.\n\nArguments\n\nxk: vector of x-coordinates of data [assumed distinct].\nfk: vector of y-coordinates of data.\nx:  vector of x-values where polynomial interpolant is to be evaluated.\n\nOutputs\n\np:    Vector of interpolated values.\n\nDetails\n\nExcept for certain nice node distributions polynomial interpolation of high-degree is an ill-conditioned problem.  This code does not test for conditioning so use with care.\n\n\n\n\n\n","category":"function"},{"location":"api/#Fourier","page":"Library","title":"Fourier","text":"","category":"section"},{"location":"api/","page":"Library","title":"Library","text":"fourdif\nfourdifft\nfourint","category":"page"},{"location":"api/#DMSuite.fourdif","page":"Library","title":"DMSuite.fourdif","text":"fourdif(N,M)\n\nComputes the M'th derivative Fourier spectral differentiation matrix on grid with N equispaced points in [0,2pi)\n\nArguments\n\nN: size of differentiation matrix.\nM: derivative required [non-negative integer]\n\nOutputs\n\nx:  equispaced points 0, 2pi/N, 4pi/N, ... , (N-1)2pi/N\nDM: M'th order differentiation matrix\n\nDetails\n\nExplicit formulas are used to compute the matrices for M=1 & 2.  A discrete Fouier approach is employed for M>2. The program  computes the first column and first row & then uses the  toeplitz command to create the matrix. For M=1 & 2 the code implements a \"flipping trick\" to improve accuracy suggested by W. Don & A. Solomonoff in  SIAM J. Sci. Comp. Vol. 6, pp. 1253–1268 (1994). The flipping trick is necesary since sin(t) can be computed to high relative precision when t is small whereas sin(pi-t) cannot.\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.fourdifft","page":"Library","title":"DMSuite.fourdifft","text":"fourdifft(f,M)\n\nComputes the M-th derivative of the function f[x] using the Fourier differentiation process.  The function is assumed to be 2pi-periodic & the input data values f should  correspond to samples of the function at N equispaced points on [0, 2pi). The Fast Fourier Transform is used.\n\nArguments\n\nf: vector of samples of f[x] at x = 0, 2pi/N, 4pi/N, ... , (N-1)2pi/N\nM: derivative required [non-negative integer]\n\nOutputs\n\nDmf:     M-th derivative of f\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.fourint","page":"Library","title":"DMSuite.fourint","text":"fourint(fk, x)\n\nEvaluates the trigonometric interpolant of the data (xk[j], fk[j]), where xk are equidistant nodes, at the points x. Requires two or more data points\n\nArguments\n\nfk:  vector of y-coordinates of data, at equidistant points xk[j] = (j-1)2pi/N,  j = 1...N.\nx:   vector of x-values where interpolant is to be evaluated.\n\nOutputs\n\nt:    vector of interpolated values.\n\nDetails\n\nThe code implements the barycentric formula; see page 46 in P. Henrici; Applied & Computational Complex Analysis III; Wiley; 1986.\n\n\n\n\n\n","category":"function"},{"location":"api/#Sinc","page":"Library","title":"Sinc","text":"","category":"section"},{"location":"api/","page":"Library","title":"Library","text":"sincdif\nsincdifft ","category":"page"},{"location":"api/#DMSuite.sincdif","page":"Library","title":"DMSuite.sincdif","text":"sincdif(N, M, h)\n\nComputes sinc the differentiation matrices D1, D2, ..., DM on equidistant points.\n\nArguments\n\nN: number of points; i.e.; order of differentiation matrix.\nM: number of derivatives required [integer]. Note that M must satisfy, 0 < M < N-1.\nh: step-size (real, positive).\n\nOutputs\n\nx:  vector of nodes.\nDM: DM[1:N,1:N,ell] contains ell-th derivative matrix, ell=1,...,M.\n\n\n\n\n\n","category":"function"},{"location":"api/#DMSuite.sincdifft","page":"Library","title":"DMSuite.sincdifft","text":"sincdifft(f, M, h)\n\nComputes the m-th derivative of the function f[x] using the sinc differentiation process.  The function is assumed to be defined on the entire real line & the input values correspond to samples of the function at N equispaced points symmetric with respect to the origin.\n\nArguments\n\nf: vector of samples of f[x] at h*[-(N-1)/2:(N-1)/2]\nM: number of derivatives required [integer]. Note that M must satisfy, 0 < M < N-1.\nh: step-size (real, positive).\n\nOutputs\n\nDmf: m-th derivative of f\n\n\n\n\n\n","category":"function"},{"location":"#DMSuite.jl","page":"Intro","title":"DMSuite.jl","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Spectral differentiation and interpolation methods under various bases (Chebyshev, Hermite, Laguerre, Legendre, Fourier, Sinc) in Julia. This suite of functionality was originally proposed and implemented in Matlab by, J. A. Weideman and S. C. Reddy (see References [1]).","category":"page"},{"location":"#Theory-of-Spectral-Methods","page":"Intro","title":"Theory of Spectral Methods","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"For information on spectral methods one could consult, Spectral Methods in Matlab (by L.N. Trefethen) for a more practical introduction, and/or Spectral Methods: Fundamentals in Single Domains (by C. Canuto, M.Y. Hussaini, A. Quarteroni, T.A. Zang) for a more theoretical treatment.","category":"page"},{"location":"#Usage","page":"Intro","title":"Usage","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"DMSuite does not depend on a specific FFT implementation, instead it is built against the abstract interface AbstractFFTs.jl. Therefore to use a method such as chebdifft, one must install and load an FFT implementation such as FFTW.jl or FastTransforms.jl.","category":"page"},{"location":"#Example","page":"Intro","title":"Example","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Solve the BVP: u = exp(4x), subject to the BCs,  u(-1)=u(1)=0","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"using FastTransforms\nusing DMSuite\nusing Plots\n\nN = 16\nM = 2\nx,DM = chebdif(N+1,M)\nD2 = DM[2:N,2:N,2]       # impose boundary conditions\nf = exp.(4 .* x[2:N])    # impose boundary conditions\n\nu = D2 \\ f     # solve\nu = [0;u;0]    # set boundary values\n\nxx = -1:0.01:1\nuu = chebint(u,xx)\nplot(xx,uu)","category":"page"},{"location":"#Alternative-Libraries","page":"Intro","title":"Alternative Libraries","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"An alternative to DMSuite, at a higher level of abstraction and with a wider feature set, is ApproxFun.jl","category":"page"}]
}
